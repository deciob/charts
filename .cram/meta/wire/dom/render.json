{"absId":"wire/dom/render","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/wire/dom/render.js","source":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dom/render plugin\n * wire plugin that provides a factory for dom nodes via a simple html\n * template.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\ndefine(['./../lib/dom/base', 'when'], function (base, when) {\n\n\tvar parentTypes, parseTemplateRx, getFirstTagNameRx, isPlainTagNameRx,\n\t\tpluginInstance, undef;\n\n\t// elements that could be used as root nodes and their natural parent type\n\tparentTypes = {\n\t\t'li': 'ul',\n\t\t'td': 'tr',\n\t\t'tr': 'tbody',\n\t\t'tbody': 'table',\n\t\t'thead': 'table',\n\t\t'tfoot': 'table',\n\t\t'caption': 'table',\n\t\t'col': 'table',\n\t\t'colgroup': 'table',\n\t\t'option': 'select'\n\t};\n\n\tparseTemplateRx = /\\$\\{([^}]*)\\}/g;\n\tgetFirstTagNameRx = /<\\s*(\\w+)/;\n\tisPlainTagNameRx = /^[A-Za-z]\\w*$/;\n\n\t/**\n\t * Constructs a DOM node and child nodes from a template string.\n\t * Information contained in a hashmap is merged into the template\n\t * via tokens (${name}) before rendering into DOM nodes.\n\t * Nothing is done with the css parameter at this time.\n\t * @param template {String} html template\n\t * @param hashmap {Object} string replacements hash\n\t * @param optRefNode {HTMLElement} node to replace with root node of rendered template\n\t * @returns {HTMLElement}\n\t */\n\tfunction render (template, hashmap, optRefNode /*, optCss */) {\n\t\tvar node;\n\n\t\t// replace tokens (before attempting to find top tag name)\n\t\ttemplate = replaceTokens('' + template, hashmap);\n\n\t\tif (isPlainTagNameRx.test(template)) {\n\t\t\t// just 'div' or 'a' or 'tr', for example\n\t\t\tnode = document.createElement(template);\n\t\t}\n\t\telse {\n\t\t\t// create node from template\n\t\t\tnode = createElementFromTemplate(template);\n\t\t}\n\n\t\tif (optRefNode) {\n\t\t\tnode = safeReplaceElement(node, optRefNode);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tpluginInstance = {\n\t\tfactories: {\n\t\t\trender: domRenderFactory\n\t\t},\n\t\tproxies: [\n\t\t\tbase.proxyNode\n\t\t]\n\t};\n\n\trender.wire$plugin = function (/* options */) {\n\t\treturn pluginInstance;\n\t};\n\n\t/**\n\t * Finds the first html element in a string, extracts its tag name,\n\t * and looks up the natural parent element tag name for this element.\n\t * @private\n\t * @param template {String}\n\t * @returns {String} the parent tag name, or 'div' if none was found.\n\t */\n\tfunction getParentTagName (template) {\n\t\tvar matches;\n\n\t\t// TODO: throw if no element was ever found?\n\t\tmatches = template.match(getFirstTagNameRx);\n\n\t\treturn parentTypes[matches && matches[1]] || 'div';\n\t}\n\n\t/**\n\t * Creates an element from a text template.  This function does not\n\t * support multiple elements in a template.  Leading and trailing\n\t * text and/or comments are also ignored.\n\t * @private\n\t * @param template {String}\n\t * @returns {HTMLElement} the element created from the template\n\t */\n\tfunction createElementFromTemplate (template) {\n\t\tvar parentTagName, parent, first, tooMany, node;\n\n\t\tparentTagName = getParentTagName(template);\n\t\tparent = document.createElement(parentTagName);\n\t\tparent.innerHTML = template;\n\n\t\t// we just want to return first element (nodelists and fragments\n\t\t// are tricky), so we ensure we only have one.\n\t\t// TODO: try using DocumentFragments to allow multiple root elements\n\n\t\t// try html5-ish API\n\t\tif ('firstElementChild' in parent) {\n\t\t\tfirst = parent.firstElementChild;\n\t\t\ttooMany = first != parent.lastElementChild;\n\t\t}\n\t\telse {\n\t\t\t// loop through nodes looking for elements\n\t\t\tnode = parent.firstChild;\n\t\t\twhile (node && !tooMany) {\n\t\t\t\tif (node.nodeType == 1 /* 1 == element */) {\n\t\t\t\t\tif (!first) first = node;\n\t\t\t\t\telse tooMany = true;\n\t\t\t\t}\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\t\t}\n\n\t\tif (!first) {\n\t\t\tthrow new Error('render: no element found in template.');\n\t\t}\n\t\telse if (tooMany) {\n\t\t\tthrow new Error('render: only one root element per template is supported.');\n\t\t}\n\n\t\treturn first;\n\t}\n\n\t/**\n\t * Creates rendered dom trees for the \"render\" factory.\n\t * @param resolver\n\t * @param componentDef\n\t * @param wire\n\t */\n\tfunction domRenderFactory (resolver, componentDef, wire) {\n\t\twhen(wire(componentDef.options), function (options) {\n\t\t\tvar template;\n\t\t\ttemplate = options.template || options;\n\t\t\treturn render(template, options.replace, options.at, options.css);\n\t\t}).then(resolver.resolve, resolver.reject);\n\t}\n\n\t/**\n\t * Replaces a dom node, while preserving important attributes\n\t * of the original.\n\t * @private\n\t * @param oldNode {HTMLElement}\n\t * @param newNode {HTMLElement}\n\t * @returns {HTMLElement} newNode\n\t */\n\tfunction safeReplaceElement (newNode, oldNode) {\n\t\tvar i, attr, parent;\n\n\t\tfor (i = 0; i < oldNode.attributes.length; i++) {\n\t\t\tattr = oldNode.attributes[i];\n\t\t\tif ('class' == attr.name) {\n\t\t\t\t// merge css classes\n\t\t\t\t// TODO: if we want to be smart about not duplicating classes, implement spliceClassNames from cola/dom/render\n\t\t\t\tnewNode.className = (oldNode.className ? oldNode.className + ' ' : '')\n\t\t\t\t\t+ newNode.className;\n\t\t\t}\n\t\t\t// Note: IE6&7 don't support node.hasAttribute() so we're using node.attributes\n\t\t\telse if (!newNode.attributes[attr.name]) {\n\t\t\t\tnewNode.setAttribute(attr.name, oldNode.getAttribute(attr.name));\n\t\t\t}\n\t\t}\n\t\tparent = oldNode.parentNode;\n\t\tif (parent) {\n\t\t\tparent.replaceChild(newNode, oldNode);\n\t\t}\n\t\treturn newNode;\n\t}\n\n\t/**\n\t * Replaces simple tokens in a string.  Tokens are in the format ${key}.\n\t * Tokens are replaced by values looked up in an associated hashmap.\n\t * If a token's key is not found in the hashmap, an empty string is\n\t * inserted instead.\n\t * @private\n\t * @param template\n\t * @param hashmap {Object} the names of the properties of this object\n\t * are used as keys. The values replace the token in the string.\n\t * @param [missing] {Function} callback that deals with missing properties\n\t * @returns {String}\n\t */\n\tfunction replaceTokens (template, hashmap, missing) {\n\t\tif (!hashmap) {\n\t\t\treturn template;\n\t\t}\n\n\t\tif (!missing) {\n\t\t\tmissing = blankIfMissing;\n\t\t}\n\t\t\n\t\treturn template.replace(parseTemplateRx, function (m, token) {\n\t\t\treturn missing(findProperty(hashmap, token));\n\t\t});\n\t}\n\n\tfunction findProperty (obj, propPath) {\n\t\tvar props, prop;\n\t\tprops = propPath.split('.');\n\t\twhile (obj && (prop = props.shift())) {\n\t\t\tobj = obj[prop];\n\t\t}\n\t\treturn obj;\n\t}\n\n\tfunction blankIfMissing (val) { return val == undef ? '' : val; }\n\n\treturn render;\n\n});\n","modules":[{"pos":352,"count":60,"depList":["wire/lib/dom/base","when/when"],"factory":true,"argList":["base","when"],"id":"wire/dom/render"}],"compileTime":"2014-03-24T21:53:07.509Z"}