{"absId":"wire/lib/plugin/basePlugin","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/wire/lib/plugin/basePlugin.js","source":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Base wire plugin that provides properties, init, and destroy facets, and\n * a proxy for plain JS objects.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when, object, functional, pipeline, instantiate, createInvoker,\n\t\twhenAll, obj, pluginInstance, undef;\n\n\twhen = require('when');\n\tobject = require('../object');\n\tfunctional = require('../functional');\n\tpipeline = require('../pipeline');\n\tinstantiate = require('../instantiate');\n\tcreateInvoker = require('../invoker');\n\n\twhenAll = when.all;\n\n\tobj = {};\n\n\tfunction asArray(it) {\n\t\treturn Array.isArray(it) ? it : [it];\n\t}\n\n\tfunction invoke(func, proxy, args, wire) {\n        return when(wire(args, func, proxy.path),\n\t\t\tfunction (resolvedArgs) {\n\t\t\t\treturn proxy.invoke(func, asArray(resolvedArgs));\n\t\t\t}\n\t\t);\n\t}\n\n\tfunction invokeAll(facet, wire) {\n\t\tvar options = facet.options;\n\n\t\tif(typeof options == 'string') {\n\t\t\treturn invoke(options, facet, [], wire);\n\n\t\t} else {\n\t\t\tvar promises, funcName;\n\t\t\tpromises = [];\n\n\t\t\tfor(funcName in options) {\n\t\t\t\tpromises.push(invoke(funcName, facet, options[funcName], wire));\n\t\t\t}\n\n\t\t\treturn whenAll(promises);\n\t\t}\n\t}\n\n\t//\n\t// Mixins\n\t//\n\n\tfunction mixin(target, src) {\n\t\tvar name, s;\n\n\t\tfor(name in src) {\n\t\t\ts = src[name];\n\t\t\tif(!(name in target) || (target[name] !== s && (!(name in obj) || obj[name] !== s))) {\n\t\t\t\ttarget[name] = s;\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tfunction doMixin(target, introduction, wire) {\n\t\tintroduction = typeof introduction == 'string'\n\t\t\t? wire.resolveRef(introduction)\n\t\t\t: wire(introduction);\n\n\t\treturn when(introduction, mixin.bind(null, target));\n\t}\n\n\tfunction mixinFacet(resolver, facet, wire) {\n\t\tvar target, intros;\n\n\t\ttarget = facet.target;\n\t\tintros = facet.options;\n\n\t\tif(!Array.isArray(intros)) {\n\t\t\tintros = [intros];\n\t\t}\n\n\t\tresolver.resolve(when.reduce(intros, function(target, intro) {\n\t\t\treturn doMixin(target, intro, wire);\n\t\t}, target));\n\t}\n\n    /**\n     * Factory that handles cases where you need to create an object literal\n     * that has a property whose name would trigger another wire factory.\n     * For example, if you need an object literal with a property named \"create\",\n     * which would normally cause wire to try to construct an instance using\n     * a constructor or other function, and will probably result in an error,\n     * or an unexpected result:\n     * myObject: {\n     *      create: \"foo\"\n     *    ...\n     * }\n     *\n     * You can use the literal factory to force creation of an object literal:\n     * myObject: {\n     *    literal: {\n     *      create: \"foo\"\n     *    }\n     * }\n     *\n     * which will result in myObject.create == \"foo\" rather than attempting\n     * to create an instance of an AMD module whose id is \"foo\".\n     */\n\tfunction literalFactory(resolver, spec /*, wire */) {\n\t\tresolver.resolve(spec.options);\n\t}\n\n\t/**\n\t * @deprecated Use create (instanceFactory) instead\n\t * @param resolver\n\t * @param componentDef\n\t * @param wire\n\t */\n\tfunction protoFactory(resolver, componentDef, wire) {\n\t\tvar parentRef, promise;\n\n        parentRef = componentDef.options;\n\n        promise = typeof parentRef === 'string'\n                ? wire.resolveRef(parentRef)\n                : wire(parentRef);\n\n\t\tresolver.resolve(promise.then(Object.create));\n\t}\n\n\tfunction propertiesFacet(resolver, facet, wire) {\n\n\t\tvar properties, path, setProperty, propertiesSet;\n\n\t\tproperties = facet.options;\n\t\tpath = facet.path;\n\t\tsetProperty = facet.set.bind(facet);\n\n\t\tpropertiesSet = when.map(Object.keys(facet.options), function(key) {\n\t\t\treturn wire(properties[key], facet.path)\n\t\t\t\t.then(function(wiredProperty) {\n\t\t\t\t\tsetProperty(key, wiredProperty);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\n\t\tresolver.resolve(propertiesSet);\n\t}\n\n\tfunction invokerFactory(resolver, componentDef, wire) {\n\n\t\tvar invoker = wire(componentDef.options).then(function (invokerContext) {\n\t\t\t// It'd be nice to use wire.getProxy() then proxy.invoke()\n\t\t\t// here, but that means the invoker must always return\n\t\t\t// a promise.  Not sure that's best, so for now, just\n\t\t\t// call the method directly\n\t\t\treturn createInvoker(invokerContext.method, invokerContext.args);\n\t\t});\n\n\t\tresolver.resolve(invoker);\n\t}\n\n\tfunction invokerFacet(resolver, facet, wire) {\n\t\tresolver.resolve(invokeAll(facet, wire));\n\t}\n\n    //noinspection JSUnusedLocalSymbols\n    /**\n     * Wrapper for use with when.reduce that calls the supplied destroyFunc\n     * @param [unused]\n     * @param destroyFunc {Function} destroy function to call\n     */\n    function destroyReducer(unused, destroyFunc) {\n        return destroyFunc();\n    }\n\n\tfunction cloneFactory(resolver, componentDef, wire) {\n\t\tvar sourceRef, options, cloned;\n\n\t\tif (wire.resolver.isRef(componentDef.options.source)) {\n\t\t\tsourceRef = componentDef.options.source;\n\t\t\toptions = componentDef.options;\n\t\t}\n\t\telse {\n\t\t\tsourceRef = componentDef.options;\n\t\t\toptions = {};\n\t\t}\n\n\t\tcloned = wire(sourceRef).then(function (ref) {\n\t\t\treturn when(wire.getProxy(ref), function (proxy) {\n\t\t\t\tif (!proxy.clone) {\n\t\t\t\t\tthrow new Error('No clone function found for ' + componentDef.id);\n\t\t\t\t}\n\n\t\t\t\treturn proxy.clone(options);\n\t\t\t});\n\t\t});\n\n\t\tresolver.resolve(cloned);\n\t}\n\n\tfunction moduleFactory(resolver, componentDef, wire) {\n\t\tresolver.resolve(wire.loadModule(componentDef.options));\n\t}\n\n\t/**\n\t * Factory that uses an AMD module either directly, or as a\n\t * constructor or plain function to create the resulting item.\n\t *\n\t * @param {Object} resolver resolver to resolve with the created component\n\t * @param {Object} componentDef portion of the spec for the component to be created\n\t * @param {function} wire\n\t */\n\tfunction instanceFactory(resolver, componentDef, wire) {\n\t\tvar create, args, isConstructor, module, instance;\n\n\t\tcreate = componentDef.options;\n\n\t\tif (typeof create == 'string') {\n\t\t\tmodule = wire.loadModule(create);\n\t\t} else if(wire.resolver.isRef(create)) {\n\t\t\tmodule = wire(create);\n\t\t} else if(object.isObject(create) && create.module) {\n\t\t\tmodule = wire.loadModule(create.module);\n\t\t\targs = create.args ? wire(asArray(create.args)) : [];\n\t\t\tisConstructor = create.isConstructor;\n\t\t} else {\n\t\t\tmodule = create;\n\t\t}\n\n\t\tinstance = when.join(module, args).spread(createInstance);\n\n\t\tresolver.resolve(instance);\n\n\t\t// Load the module, and use it to create the object\n\t\tfunction createInstance(module, args) {\n\t\t\t// We'll either use the module directly, or we need\n\t\t\t// to instantiate/invoke it.\n\t\t\treturn typeof module == 'function'\n\t\t\t\t? instantiate(module, args, isConstructor)\n\t\t\t\t: Object.create(module);\n\t\t}\n\t}\n\n\tfunction composeFactory(resolver, componentDef, wire) {\n\t\tvar options, promise;\n\n\t\toptions = componentDef.options;\n\n\t\tif(typeof options == 'string') {\n\t\t\tpromise = pipeline(undef, options, wire);\n\t\t} else {\n\t\t\t// Assume it's an array of things that will wire to functions\n\t\t\tpromise = when(wire(options), function(funcArray) {\n\t\t\t\treturn functional.compose(funcArray);\n\t\t\t});\n\t\t}\n\n\t\tresolver.resolve(promise);\n\t}\n\n\tpluginInstance = {\n\t\tfactories: {\n\t\t\tmodule: moduleFactory,\n\t\t\tcreate: instanceFactory,\n\t\t\tliteral: literalFactory,\n\t\t\tprototype: protoFactory,\n\t\t\tclone: cloneFactory,\n\t\t\tcompose: composeFactory,\n\t\t\tinvoker: invokerFactory\n\t\t},\n\t\tfacets: {\n\t\t\t// properties facet.  Sets properties on components\n\t\t\t// after creation.\n\t\t\tproperties: {\n\t\t\t\tconfigure: propertiesFacet\n\t\t\t},\n\t\t\tmixin: {\n\t\t\t\tconfigure: mixinFacet\n\t\t\t},\n\t\t\t// init facet.  Invokes methods on components during\n\t\t\t// the \"init\" stage.\n\t\t\tinit: {\n\t\t\t\tinitialize: invokerFacet\n\t\t\t},\n\t\t\t// ready facet.  Invokes methods on components during\n\t\t\t// the \"ready\" stage.\n\t\t\tready: {\n\t\t\t\tready: invokerFacet\n\t\t\t},\n\t\t\t// destroy facet.  Registers methods to be invoked\n\t\t\t// on components when the enclosing context is destroyed\n\t\t\tdestroy: {\n\t\t\t\tdestroy: invokerFacet\n\t\t\t}\n\t\t}\n\t};\n\n\t// \"introduce\" is deprecated, but preserved here for now.\n\tpluginInstance.facets.introduce = pluginInstance.facets.mixin;\n\n\treturn function(/* options */) {\n\t\treturn pluginInstance;\n\t};\n});\n})(typeof define == 'function'\n\t? define\n\t: function(factory) { module.exports = factory(require); }\n);\n","modules":[{"pos":385,"count":25,"factory":true,"argList":["require"],"requires":[{"id":"when","pos":530,"count":15},{"id":"../object","pos":557,"count":20},{"id":"../functional","pos":593,"count":24},{"id":"../pipeline","pos":631,"count":22},{"id":"../instantiate","pos":670,"count":25},{"id":"../invoker","pos":714,"count":21}],"id":"wire/lib/plugin/basePlugin"}],"compileTime":"2014-03-24T21:53:07.514Z"}