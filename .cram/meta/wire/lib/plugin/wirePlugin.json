{"absId":"wire/lib/plugin/wirePlugin","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/wire/lib/plugin/wirePlugin.js","source":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Plugin that allows wire to be used as a plugin within a wire spec\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when, object;\n\n\twhen = require('when');\n\tobject = require('../object');\n\n\treturn function(/* options */) {\n\n\t\tvar ready = when.defer();\n\n\t\treturn {\n\t\t\tcontext: {\n\t\t\t\tready: function(resolver) {\n\t\t\t\t\tready.resolve();\n\t\t\t\t\tresolver.resolve();\n\t\t\t\t}\n\t\t\t},\n\t\t\tresolvers: {\n\t\t\t\twire: wireResolver\n\t\t\t},\n\t\t\tfactories: {\n\t\t\t\twire: wireFactory\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Factory that creates either a child context, or a *function* that will create\n\t\t * that child context.  In the case that a child is created, this factory returns\n\t\t * a promise that will resolve when the child has completed wiring.\n\t\t *\n\t\t * @param {Object} resolver used to resolve with the created component\n\t\t * @param {Object} componentDef component spec for the component to be created\n\t\t * @param {function} wire scoped wire function\n\t\t */\n\t\tfunction wireFactory(resolver, componentDef, wire) {\n\t\t\tvar options, module, provide, defer, waitParent, result;\n\n\t\t\toptions = componentDef.options;\n\n\t\t\t// Get child spec and options\n\t\t\tif(object.isObject(options) && 'spec' in options) {\n\t\t\t\tmodule = options.spec;\n\t\t\t\twaitParent = options.waitParent;\n\t\t\t\tdefer = options.defer;\n\t\t\t\tprovide = options.provide;\n\t\t\t} else {\n\t\t\t\tmodule = options;\n\t\t\t}\n\n\t\t\tfunction init(context) {\n\t\t\t\tvar initialized;\n\n\t\t\t\tif(provide) {\n\t\t\t\t\tinitialized = when(wire(provide), function(provides) {\n\t\t\t\t\t\tobject.mixin(context.instances, provides);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn initialized;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Create a child context of the current context\n\t\t\t * @param {object?} mixin additional spec to be mixed into\n\t\t\t *  the child being wired\n\t\t\t * @returns {Promise} promise for child context\n\t\t\t */\n\t\t\tfunction createChild(/** {Object|String}? */ mixin) {\n\t\t\t\tvar spec, config;\n\n\t\t\t\tspec = mixin ? [].concat(module, mixin) : module;\n\t\t\t\tconfig = { initializers: [init] };\n\n\t\t\t\tvar child = wire.createChild(spec, config);\n\t\t\t\treturn defer ? child\n\t\t\t\t\t: when(child, function(child) {\n\t\t\t\t\treturn object.hasOwn(child, '$exports') ? child.$exports : child;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (defer) {\n\t\t\t\t// Resolve with the createChild *function* itself\n\t\t\t\t// which can be used later to wire the spec\n\t\t\t\tresult = createChild;\n\n\t\t\t} else if(waitParent) {\n\n\t\t\t\tvar childPromise = when(ready.promise, function() {\n\t\t\t\t\t// ensure nothing is passed to createChild here\n\t\t\t\t\treturn createChild();\n\t\t\t\t});\n\n\t\t\t\tresult = wrapChild(childPromise);\n\n\t\t\t} else {\n\t\t\t\tresult = createChild();\n\t\t\t}\n\n\t\t\tresolver.resolve(result);\n\t\t}\n\t};\n\n\tfunction wrapChild(promise) {\n\t\treturn { promise: promise };\n\t}\n\n\t/**\n\t * Builtin reference resolver that resolves to the context-specific\n\t * wire function.\n\t */\n\tfunction wireResolver(resolver, _, __, wire) {\n\t\tresolver.resolve(wire.createChild);\n\t}\n\n});\n}(typeof define === 'function' ? define : function(factory) { module.exports = factory(require); }));\n","modules":[{"pos":331,"count":25,"factory":true,"argList":["require"],"requires":[{"id":"when","pos":387,"count":15},{"id":"../object","pos":414,"count":20}],"id":"wire/lib/plugin/wirePlugin"}],"compileTime":"2014-03-24T21:53:07.489Z"}