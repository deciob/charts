{"absId":"wire/lib/pipeline","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/wire/lib/pipeline.js","source":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when, compose, pipelineSplitRx;\n\n\twhen = require('when');\n\tcompose = require('./functional').compose;\n\tpipelineSplitRx = /\\s*\\|\\s*/;\n\n\treturn function pipeline(proxy, composeString, wire) {\n\n\t\tvar bindSpecs, resolveRef, getProxy;\n\n\t\tif(typeof composeString != 'string') {\n\t\t\treturn wire(composeString).then(function(func) {\n\t\t\t\treturn createProxyInvoker(proxy, func);\n\t\t\t});\n\t\t}\n\n\t\tbindSpecs = composeString.split(pipelineSplitRx);\n\t\tresolveRef = wire.resolveRef;\n\t\tgetProxy = wire.getProxy;\n\n\t\tfunction createProxyInvoker(proxy, method) {\n\t\t\treturn function() {\n\t\t\t\treturn proxy.invoke(method, arguments);\n\t\t\t};\n\t\t}\n\n\t\tfunction createBound(proxy, bindSpec) {\n\t\t\tvar target, method;\n\n\t\t\ttarget = bindSpec.split('.');\n\n\t\t\tif(target.length > 2) {\n\t\t\t\tthrow new Error('Only 1 \".\" is allowed in refs: ' + bindSpec);\n\t\t\t}\n\n\t\t\tif(target.length > 1) {\n\t\t\t\tmethod = target[1];\n\t\t\t\ttarget = target[0];\n\t\t\t\treturn when(getProxy(target), function(proxy) {\n\t\t\t\t\treturn createProxyInvoker(proxy, method);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif(proxy && typeof proxy.get(bindSpec) == 'function') {\n\t\t\t\t\treturn createProxyInvoker(proxy, bindSpec);\n\t\t\t\t} else {\n\t\t\t\t\treturn resolveRef(bindSpec);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// First, resolve each transform function, stuffing it into an array\n\t\t// The result of this reduce will an array of concrete functions\n\t\t// Then add the final context[method] to the array of funcs and\n\t\t// return the composition.\n\t\treturn when.reduce(bindSpecs, function(funcs, bindSpec) {\n\t\t\treturn when(createBound(proxy, bindSpec), function(func) {\n\t\t\t\tfuncs.push(func);\n\t\t\t\treturn funcs;\n\t\t\t});\n\t\t}, []).then(\n\t\t\tfunction(funcs) {\n\t\t\t\tvar context = proxy && proxy.target;\n\t\t\t\treturn (funcs.length == 1 ? funcs[0] : compose(funcs)).bind(context);\n\t\t\t}\n\t\t);\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","modules":[{"pos":267,"count":25,"factory":true,"argList":["require"],"requires":[{"id":"when","pos":341,"count":15},{"id":"./functional","pos":369,"count":23}],"id":"wire/lib/pipeline"}],"compileTime":"2014-03-24T21:53:07.513Z"}