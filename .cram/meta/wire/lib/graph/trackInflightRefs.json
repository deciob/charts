{"absId":"wire/lib/graph/trackInflightRefs","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/wire/lib/graph/trackInflightRefs.js","source":"/**\n * trackInflightRefs\n * @author: brian@hovercraftstudios.com\n */\n(function(define) {\ndefine(function(require) {\n\n\tvar timeout, findStronglyConnected, formatCycles, refCycleCheckTimeout;\n\n\ttimeout = require('when/timeout');\n\tfindStronglyConnected = require('./tarjan');\n\tformatCycles = require('./formatCycles');\n\n\trefCycleCheckTimeout = 5000;\n\n\t/**\n\t * Advice to track inflight refs using a directed graph\n\t * @param {DirectedGraph} graph\n\t * @param {Resolver} resolver\n\t * @param {number} cycleTimeout how long to wait for any one reference to resolve\n\t *  before performing cycle detection. This basically debounces cycle detection\n\t */\n\treturn function trackInflightRefs(graph, resolver, cycleTimeout) {\n\t\tvar create = resolver.create;\n\n\t\tif(typeof cycleTimeout != 'number') {\n\t\t\tcycleTimeout = refCycleCheckTimeout;\n\t\t}\n\n\t\tresolver.create = function() {\n\t\t\tvar ref, resolve;\n\n\t\t\tref = create.apply(resolver, arguments);\n\n\t\t\tresolve = ref.resolve;\n\t\t\tref.resolve = function() {\n\t\t\t\tvar inflight = resolve.apply(ref, arguments);\n\t\t\t\treturn trackInflightRef(graph, cycleTimeout, inflight, ref.name, arguments[1]);\n\t\t\t};\n\n\t\t\treturn ref;\n\t\t};\n\n\t\treturn resolver;\n\t};\n\n\n\t/**\n\t * Add this reference to the reference graph, and setup a timeout that will fire if the refPromise\n\t * has not resolved in a reasonable amount.  If the timeout fires, check the current graph for cycles\n\t * and fail wiring if we find any.\n\t * @param {DirectedGraph} refGraph graph to use to track cycles\n\t * @param {number} cycleTimeout how long to wait for any one reference to resolve\n\t *  before performing cycle detection. This basically debounces cycle detection\n\t * @param {object} refPromise promise for reference resolution\n\t * @param {string} refName reference being resolved\n\t * @param {string} onBehalfOf some indication of another component on whose behalf this\n\t *  reference is being resolved.  Used to build a reference graph and detect cycles\n\t * @return {object} promise equivalent to refPromise but that may be rejected if cycles are detected\n\t */\n\tfunction trackInflightRef(refGraph, cycleTimeout, refPromise, refName, onBehalfOf) {\n\n\t\tonBehalfOf = onBehalfOf||'?';\n\t\trefGraph.addEdge(onBehalfOf, refName);\n\n\t\treturn timeout(refPromise, cycleTimeout).then(\n\t\t\tfunction(resolved) {\n\t\t\t\trefGraph.removeEdge(onBehalfOf, refName);\n\t\t\t\treturn resolved;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tvar stronglyConnected, cycles;\n\n\t\t\t\tstronglyConnected = findStronglyConnected(refGraph);\n\t\t\t\tcycles = stronglyConnected.filter(function(node) {\n\t\t\t\t\treturn node.length > 1;\n\t\t\t\t});\n\n\t\t\t\tif(cycles.length) {\n\t\t\t\t\t// Cycles detected\n\t\t\t\t\tthrow new Error('Possible circular refs:\\n'\n\t\t\t\t\t\t+ formatCycles(cycles));\n\t\t\t\t}\n\n\t\t\t\treturn refPromise;\n\t\t\t}\n\t\t);\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","modules":[{"pos":89,"count":25,"factory":true,"argList":["require"],"requires":[{"id":"when/timeout","pos":202,"count":23},{"id":"./tarjan","pos":252,"count":19},{"id":"./formatCycles","pos":289,"count":25}],"id":"wire/lib/graph/trackInflightRefs"}],"compileTime":"2014-03-24T21:53:07.507Z"}