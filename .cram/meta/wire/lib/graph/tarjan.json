{"absId":"wire/lib/graph/tarjan","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/wire/lib/graph/tarjan.js","source":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Tarjan directed graph cycle detection\n * @author: brian@hovercraftstudios.com\n */\n(function(define) {\ndefine(function() {\n\n\tvar undef;\n\n\t/**\n\t * Tarjan directed graph cycle detection.\n\t * See http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm\n\t *\n\t * WARNING: For efficiency, this adds properties to the vertices in the\n\t * graph.  It doesn't really matter for wire's internal purposes.\n\t *\n\t * @param {DirectedGraph} digraph\n\t * @return {Array} each element is a set (Array) of vertices involved\n\t * in a cycle.\n\t */\n\treturn function tarjan(digraph) {\n\n\t\tvar index, stack, scc;\n\n\t\tindex = 0;\n\t\tstack = [];\n\n\t\tscc = [];\n\n\t\t// Clear out any old cruft that may be hanging around\n\t\t// from a previous run.  Maybe should do this afterward?\n\t\tdigraph.eachVertex(function(v) {\n\t\t\tdelete v.index;\n\t\t\tdelete v.lowlink;\n\t\t\tdelete v.onStack;\n\t\t});\n\n\t\t// Start the depth first search\n\t\tdigraph.eachVertex(function(v) {\n\t\t\tif(v.index === undef) {\n\t\t\t\tfindStronglyConnected(digraph, v)\n\t\t\t}\n\t\t});\n\n\t\t// Tarjan algorithm for a single node\n\t\tfunction findStronglyConnected(dg, v) {\n\t\t\tvar vertices, vertex;\n\n\t\t\tv.index = v.lowlink = index;\n\t\t\tindex += 1;\n\t\t\tpushStack(stack, v);\n\n\t\t\tdg.eachEdgeFrom(v.name, function(v, w) {\n\n\t\t\t\tif(w.index === undef) {\n\t\t\t\t\t// Continue depth first search\n\t\t\t\t\tfindStronglyConnected(dg, w);\n\t\t\t\t\tv.lowlink = Math.min(v.lowlink, w.lowlink);\n\t\t\t\t} else if(w.onStack) {\n\t\t\t\t\tv.lowlink = Math.min(v.lowlink, w.index);\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tif(v.lowlink === v.index) {\n\t\t\t\tvertices = [];\n\t\t\t\tif(stack.length) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tvertex = popStack(stack);\n\t\t\t\t\t\tvertices.push(vertex);\n\t\t\t\t\t} while(v !== vertex)\n\t\t\t\t}\n\n\t\t\t\tif(vertices.length) {\n\t\t\t\t\tscc.push(vertices);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn scc;\n\t};\n\n\t/**\n\t * Push a vertex on the supplied stack, but also tag the\n\t * vertex as being on the stack so we don't have to scan the\n\t * stack later in order to tell.\n\t * @param {Array} stack\n\t * @param {object} vertex\n\t */\n\tfunction pushStack(stack, vertex) {\n\t\tstack.push(vertex);\n\t\tvertex.onStack = 1;\n\t}\n\n\t/**\n\t * Pop an item off the supplied stack, being sure to un-tag it\n\t * @param {Array} stack\n\t * @return {object|undefined} vertex\n\t */\n\tfunction popStack(stack) {\n\t\tvar v = stack.pop();\n\t\tif(v) {\n\t\t\tdelete v.onStack;\n\t\t}\n\n\t\treturn v;\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","modules":[{"pos":172,"count":18,"factory":true,"id":"wire/lib/graph/tarjan"}],"compileTime":"2014-03-24T21:53:04.863Z"}