{"absId":"wire/lib/scope","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/wire/lib/scope.js","source":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author brian@hovercraftstudios.com\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when, defer, sequence, array, object, loader, Map,\n\t\tComponentFactory, Lifecycle, Resolver, WireProxy, PluginRegistry,\n\t\tundef;\n\n\twhen = require('when');\n\tsequence = require('when/sequence');\n\tarray = require('./array');\n\tobject = require('./object');\n\tMap = require('./Map');\n\tloader = require('./loader/adapter');\n\tComponentFactory = require('./ComponentFactory');\n\tLifecycle = require('./lifecycle');\n\tResolver = require('./resolver');\n\tWireProxy = require('./WireProxy');\n\tPluginRegistry = require('./plugin/registry');\n\n\tdefer = when.defer;\n\n\tfunction Scope(parent, options) {\n\t\tthis.parent = parent||{};\n\t\tobject.mixin(this, options);\n\t}\n\n\tScope.prototype = {\n\n\t\tinit: function(spec) {\n\n\t\t\tthis._inherit(this.parent);\n\t\t\tthis._init();\n\t\t\tthis._configure();\n\n\t\t\treturn this._startup(spec).yield(this);\n\t\t},\n\n\t\t_inherit: function(parent) {\n\n\t\t\tthis._instanceToProxy = new Map();\n\n\t\t\tthis.instances = this._inheritInstances(parent);\n\t\t\tthis.components = object.inherit(parent.components);\n\n\t\t\tthis.path = this._createPath(this.name, parent.path);\n\n\t\t\tthis.plugins = parent.plugins;\n\n\t\t\tthis.initializers = array.delegate(this.initializers);\n\t\t\tthis.destroyers = array.delegate(this.destroyers);\n\t\t\tthis.postDestroy = array.delegate(this.postDestroy);\n\n\t\t\tif(!this.moduleLoader) {\n\t\t\t\tthis.moduleLoader = parent.moduleLoader;\n\t\t\t}\n\t\t},\n\n\t\t_inheritInstances: function(parent) {\n\t\t\treturn object.inherit(parent.instances);\n\t\t},\n\n\t\t_addDependent: function(dependant, tasks) {\n\t\t\treturn dependant.then(\n\t\t\t\tfunction(dependant) {\n\t\t\t\t\ttasks.push(function() {\n\t\t\t\t\t\treturn dependant.destroy();\n\t\t\t\t\t});\n\t\t\t\t\treturn dependant;\n\t\t\t\t}\n\t\t\t);\n\n\t\t},\n\n\t\t_createNestedScope: function(spec) {\n\t\t\tvar options = { createContext: this.createContext };\n\t\t\treturn this._addDependent(\n\t\t\t\tnew Scope(this, options).init(spec), this.postDestroy);\n\t\t},\n\n\t\t_createChildContext: function(spec, options) {\n\t\t\t// Create child and arrange for it to be destroyed just before\n\t\t\t// this scope is destroyed\n\t\t\treturn this._addDependent(\n\t\t\t\tthis.createContext(spec, this, options), this.destroyers);\n\t\t},\n\n\t\t_init: function() {\n\t\t\tthis._pluginApi = this._initPluginApi();\n\t\t},\n\n\t\t_initPluginApi: function() {\n\t\t\t// Plugin API\n\t\t\t// wire() API that is passed to plugins.\n\t\t\tvar self, pluginApi;\n\n\t\t\tself = this;\n\t\t\tpluginApi = {};\n\n\t\t\tpluginApi.contextualize = function(name) {\n\t\t\t\tfunction contextualApi(spec, id) {\n\t\t\t\t\treturn self._resolveInstance(self._createComponentDef(id, spec));\n\t\t\t\t}\n\n\t\t\t\tcontextualApi.createChild = self._createChildContext.bind(self);\n\t\t\t\tcontextualApi.loadModule = self.getModule.bind(self);\n\t\t\t\tcontextualApi.resolver = self.resolver;\n\t\t\t\tcontextualApi.addComponent = addComponent;\n\t\t\t\tcontextualApi.addInstance = addInstance;\n\n\t\t\t\tcontextualApi.resolveRef = function(ref) {\n\t\t\t\t\tvar onBehalfOf = arguments.length > 1 ? arguments[2] : name;\n\t\t\t\t\treturn self._resolveRef(ref, onBehalfOf);\n\t\t\t\t};\n\n\t\t\t\tcontextualApi.getProxy = function(nameOrComponent) {\n\t\t\t\t\tvar onBehalfOf = arguments.length > 1 ? arguments[2] : name;\n\t\t\t\t\treturn self.getProxy(nameOrComponent, onBehalfOf);\n\t\t\t\t};\n\n\t\t\t\treturn contextualApi;\n\t\t\t};\n\n\t\t\treturn pluginApi;\n\n\t\t\tfunction addComponent(component, id) {\n\t\t\t\tvar def, instance;\n\n\t\t\t\tdef = self._createComponentDef(id);\n\t\t\t\tinstance = self.componentFactory.processComponent(def, component);\n\n\t\t\t\treturn self._makeResolvable(def, instance);\n\t\t\t}\n\n\t\t\tfunction addInstance(instance, id) {\n\t\t\t\tself._makeResolvable(self._createComponentDef(id), instance);\n\t\t\t\treturn when.resolve(instance);\n\t\t\t}\n\t\t},\n\n\t\t_configure: function() {\n\t\t\tvar plugins, pluginApi;\n\n\t\t\tplugins = this.plugins;\n\t\t\tpluginApi = this._pluginApi;\n\n\t\t\tthis.resolver = this._createResolver(plugins, pluginApi);\n\t\t\tthis.componentFactory = this._createComponentFactory(plugins, pluginApi);\n\n\t\t\tthis._destroy = function() {\n\t\t\t\tthis._destroy = noop;\n\n\t\t\t\treturn this._executeDestroyers()\n\t\t\t\t\t.then(this._destroyComponents.bind(this))\n\t\t\t\t\t.then(this._releaseResources.bind(this))\n\t\t\t\t\t.then(this._executePostDestroy.bind(this));\n\t\t\t};\n\t\t},\n\n\t\t_startup: function(spec) {\n\t\t\tvar self = this;\n\n\t\t\treturn this._executeInitializers().then(function() {\n\t\t\t\tvar parsed = self._parseSpec(spec);\n\t\t\t\treturn self._createComponents(parsed).then(function() {\n\t\t\t\t\treturn self._awaitInstances(parsed);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\tdestroy: function() {\n\t\t\treturn this._destroy();\n\t\t},\n\n\t\t_destroy: noop,\n\n\t\t_destroyComponents: function() {\n\t\t\tvar instances = this.instances;\n\n\t\t\treturn this.componentFactory.destroy().then(function() {\n\t\t\t\tfor (var p in instances) {\n\t\t\t\t\tdelete instances[p];\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_releaseResources: function() {\n\t\t\t// Free Objects\n\t\t\tthis.instances = this.components = this.parent\n\t\t\t\t= this.resolver = this.componentFactory\n\t\t\t\t= this._instanceToProxy = this._pluginApi = this.plugins\n\t\t\t\t= undef;\n\t\t},\n\n\t\tgetModule: function(moduleId) {\n\t\t\treturn typeof moduleId == 'string'\n\t\t\t\t? this.moduleLoader(moduleId)\n\t\t\t\t: when.resolve(moduleId);\n\t\t},\n\n\t\tgetProxy: function(nameOrInstance, onBehalfOf) {\n\t\t\tvar self = this;\n\n\t\t\tif(typeof nameOrInstance === 'string') {\n\t\t\t\treturn this._resolveRefName(nameOrInstance, {}, onBehalfOf)\n\t\t\t\t\t.then(function (instance) {\n\t\t\t\t\t\treturn self._getProxyForInstance(instance);\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn self._getProxyForInstance(nameOrInstance);\n\t\t\t}\n\t\t},\n\n\t\t_getProxyForInstance: function(instance) {\n\t\t\tvar componentFactory = this.componentFactory;\n\n\t\t\treturn getProxyRecursive(this, instance).otherwise(function() {\n\t\t\t\t// Last ditch, create a new proxy\n\t\t\t\treturn componentFactory.createProxy(instance);\n\t\t\t});\n\t\t},\n\n\t\t_createResolver: function(plugins, pluginApi) {\n\t\t\treturn new Resolver(plugins.resolvers, pluginApi);\n\t\t},\n\n\t\t_createComponentFactory: function(plugins, pluginApi) {\n\t\t\tvar self, factory, init, lifecycle;\n\n\t\t\tself = this;\n\n\t\t\tlifecycle = new Lifecycle(plugins, pluginApi);\n\t\t\tfactory = new ComponentFactory(lifecycle, plugins, pluginApi);\n\n\t\t\tinit = factory.initInstance;\n\t\t\tfactory.initInstance = function() {\n\t\t\t\treturn when(init.apply(factory, arguments), function(proxy) {\n\t\t\t\t\treturn self._makeResolvable(proxy.metadata, proxy);\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn factory;\n\t\t},\n\n\t\t_executeInitializers: function() {\n\t\t\treturn sequence(this.initializers, this);\n\t\t},\n\n\t\t_executeDestroyers: function() {\n\t\t\treturn sequence(this.destroyers, this);\n\t\t},\n\n\t\t_executePostDestroy: function() {\n\t\t\treturn sequence(this.postDestroy, this);\n\t\t},\n\n\t\t_parseSpec: function(spec) {\n\t\t\tvar instances, components, ready, plugins, id, initialized, ready;\n\n\t\t\tinstances = this.instances;\n\t\t\tcomponents = this.components;\n\t\t\tready = {};\n\n\t\t\t// Setup a promise for each item in this scope\n\t\t\tfor (id in spec) {\n\t\t\t\tif(id === '$plugins' || id === 'plugins') {\n\t\t\t\t\tplugins = spec[id];\n\t\t\t\t} else if (!object.hasOwn(instances, id)) {\n\t\t\t\t\t// An initializer may have inserted concrete components\n\t\t\t\t\t// into the context.  If so, they override components of the\n\t\t\t\t\t// same name from the input spec\n\t\t\t\t\tinitialized = defer();\n\t\t\t\t\tready = defer();\n\t\t\t\t\tcomponents[id] = this._createComponentDef(id, spec[id], initialized, ready);\n\t\t\t\t\tinstances[id] = initialized.promise;\n\t\t\t\t\tready[id] = ready.promise;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tplugins: plugins,\n\t\t\t\tcomponents: components,\n\t\t\t\tinstances: instances,\n\t\t\t\tready: ready\n\t\t\t};\n\t\t},\n\n\t\t_createComponentDef: function(id, spec, initialized, ready) {\n\t\t\treturn {\n\t\t\t\tid: id,\n\t\t\t\tspec: spec,\n\t\t\t\tpath: this._createPath(id, this.path),\n\t\t\t\tinitialized: initialized,\n\t\t\t\tready: ready\n\t\t\t};\n\t\t},\n\n\t\t_createComponents: function(parsed) {\n\t\t\t// Process/create each item in scope and resolve its\n\t\t\t// promise when completed.\n\t\t\tvar self, components;\n\n\t\t\tself = this;\n\t\t\tcomponents = parsed.components;\n\t\t\treturn when.map(Object.keys(components), function(name) {\n\t\t\t\treturn self._createScopeItem(components[name]);\n\t\t\t});\n\t\t},\n\n\t\t_awaitInstances: function(parsed) {\n\t\t\tvar ready = parsed.ready;\n\t\t\treturn when.map(Object.keys(ready), function(id) {\n\t\t\t\treturn ready[id];\n\t\t\t});\n\t\t},\n\n\t\t_createScopeItem: function(component) {\n\t\t\t// NOTE: Order is important here.\n\t\t\t// The object & local property assignment MUST happen before\n\t\t\t// the chain resolves so that the concrete item is in place.\n\t\t\t// Otherwise, the whole scope can be marked as resolved before\n\t\t\t// the final item has been resolved.\n\t\t\tvar self, item;\n\n\t\t\tself = this;\n\t\t\titem = this._resolveItem(component).then(function (resolved) {\n\t\t\t\tself._makeResolvable(component, resolved);\n\t\t\t\treturn WireProxy.getTarget(resolved);\n\t\t\t});\n\n\t\t\tcomponent.ready.resolve(item);\n\t\t\treturn item;\n\t\t},\n\n\t\t_makeResolvable: function(component, instance) {\n\t\t\tvar id, inst;\n\n\t\t\tid = component.id;\n\t\t\tif(id != null) {\n\t\t\t\tinst = WireProxy.getTarget(instance);\n\t\t\t\tthis.instances[id] = inst;\n\t\t\t\tif(component.proxy) {\n\t\t\t\t\tthis._instanceToProxy.set(inst, component.proxy);\n\t\t\t\t}\n\t\t\t\tif(component.initialized) {\n\t\t\t\t\tcomponent.initialized.resolve(inst);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn instance;\n\t\t},\n\n\t\t_resolveInstance: function(component) {\n\t\t\treturn this._resolveItem(component).then(WireProxy.getTarget);\n\t\t},\n\n\t\t_resolveItem: function(component) {\n\t\t\tvar item, spec;\n\n\t\t\tspec = component.spec;\n\n\t\t\tif (this.resolver.isRef(spec)) {\n\t\t\t\t// Reference\n\t\t\t\titem = this._resolveRef(spec, component.id);\n\t\t\t} else {\n\t\t\t\t// Component\n\t\t\t\titem = this._createItem(component);\n\t\t\t}\n\n\t\t\treturn item;\n\t\t},\n\n\t\t_createItem: function(component) {\n\t\t\tvar created, spec;\n\n\t\t\tspec = component.spec;\n\n\t\t\tif (Array.isArray(spec)) {\n\t\t\t\t// Array\n\t\t\t\tcreated = this._createArray(component);\n\n\t\t\t} else if (object.isObject(spec)) {\n\t\t\t\t// component spec, create the component\n\t\t\t\tcreated = this._createComponent(component);\n\n\t\t\t} else {\n\t\t\t\t// Plain value\n\t\t\t\tcreated = when.resolve(spec);\n\t\t\t}\n\n\t\t\treturn created;\n\t\t},\n\n\t\t_createArray: function(component) {\n\t\t\tvar self, id, i;\n\n\t\t\tself = this;\n\t\t\tid = component.id;\n\t\t\ti = 0;\n\n\t\t\t// Minor optimization, if it's an empty array spec, just return an empty array.\n\t\t\treturn when.map(component.spec, function(item) {\n\t\t\t\tvar componentDef = self._createComponentDef(id + '[' + (i++) + ']', item);\n\t\t\t\treturn self._resolveInstance(componentDef);\n\t\t\t});\n\t\t},\n\n\t\t_createComponent: function(component) {\n\t\t\tvar self = this;\n\n\t\t\treturn this.componentFactory.create(component)\n\t\t\t\t.otherwise(function (reason) {\n\t\t\t\t\tif(reason !== component) {\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t}\n\n\t\t\t\t\t// No factory found, treat object spec as a nested scope\n\t\t\t\t\treturn self._createNestedScope(component.spec)\n\t\t\t\t\t\t.then(function (childScope) {\n\t\t\t\t\t\t\t// TODO: find a lighter weight solution\n\t\t\t\t\t\t\t// We're paying the cost of creating a complete scope,\n\t\t\t\t\t\t\t// then discarding everything except the instance map.\n\t\t\t\t\t\t\treturn object.mixin({}, childScope.instances);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t_resolveRef: function(ref, onBehalfOf) {\n\t\t\tvar scope;\n\n\t\t\tref = this.resolver.parse(ref);\n\t\t\tscope = onBehalfOf == ref.name && this.parent.instances ? this.parent : this;\n\n\t\t\treturn this._doResolveRef(ref, scope.instances, onBehalfOf);\n\t\t},\n\n\t\t_resolveRefName: function(refName, options, onBehalfOf) {\n\t\t\tvar ref = this.resolver.create(refName, options);\n\n\t\t\treturn this._doResolveRef(ref, this.instances, onBehalfOf);\n\t\t},\n\n\t\t_doResolveRef: function(ref, scope, onBehalfOf) {\n\t\t\treturn ref.resolve(function (name) {\n\t\t\t\treturn resolveDeepName(name, scope);\n\t\t\t}, onBehalfOf);\n\t\t},\n\n\t\t_createPath: function(name, basePath) {\n\t\t\tvar path = basePath || this.path;\n\t\t\treturn (path && name) ? (path + '.' + name) : name;\n\t\t}\n\t};\n\n\treturn Scope;\n\n\tfunction resolveDeepName(name, scope) {\n\t\tvar parts = name.split('.');\n\n\t\tif(parts.length > 2) {\n\t\t\treturn when.reject(new Error('Only 1 \".\" is allowed in refs: ' + name));\n\t\t}\n\n\t\treturn when.reduce(parts, function(scope, segment) {\n\t\t\treturn segment in scope\n\t\t\t\t? scope[segment]\n\t\t\t\t: when.reject(new Error('Cannot resolve ref: ' + name));\n\t\t}, scope);\n\t}\n\n\tfunction getProxyRecursive(scope, instance) {\n\t\tvar proxy;\n\n\t\tif(scope._instanceToProxy) {\n\t\t\tproxy = scope._instanceToProxy.get(instance);\n\t\t}\n\n\t\tif(!proxy) {\n\t\t\tif(scope.parent) {\n\t\t\t\treturn getProxyRecursive(scope.parent, instance);\n\t\t\t} else {\n\t\t\t\treturn when.reject(new Error('No proxy found'));\n\t\t\t}\n\t\t}\n\n\t\treturn when.resolve(proxy);\n\t}\n\n\tfunction noop() {}\n\n});\n})(typeof define == 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }\n);","modules":[{"pos":240,"count":25,"factory":true,"argList":["require"],"requires":[{"id":"when","pos":410,"count":15},{"id":"when/sequence","pos":439,"count":24},{"id":"./array","pos":474,"count":18},{"id":"./object","pos":504,"count":19},{"id":"./Map","pos":532,"count":16},{"id":"./loader/adapter","pos":560,"count":27},{"id":"./ComponentFactory","pos":609,"count":29},{"id":"./lifecycle","pos":653,"count":22},{"id":"./resolver","pos":689,"count":21},{"id":"./WireProxy","pos":725,"count":22},{"id":"./plugin/registry","pos":767,"count":28}],"id":"wire/lib/scope"}],"compileTime":"2014-03-24T21:53:07.514Z"}