{"absId":"wire/lib/dom/base","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/wire/lib/dom/base.js","source":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * wire/dom/base\n * provides basic dom creation capabilities for plugins.\n *\n * wire is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n(function (define) {\ndefine(function (require) {\n\n\tvar WireProxy, priority, classRx, trimLeadingRx, splitClassNamesRx, nodeProxyInvoke;\n\n\tWireProxy = require('../WireProxy');\n\tpriority = require('../plugin/priority');\n\n\tclassRx = '(\\\\s+|^)(classNames)(\\\\b(?![\\\\-_])|$)';\n\ttrimLeadingRx = /^\\s+/;\n\tsplitClassNamesRx = /(\\b\\s+\\b)|(\\s+)/g;\n\n\t/**\n\t * Adds one or more css classes to a dom element.\n\t * @param el {HTMLElement}\n\t * @param className {String} a single css class or several, space-delimited\n\t *   css classes.\n\t */\n\tfunction addClass (el, className) {\n\t\tvar newClass;\n\n\t\tnewClass = _stripClass(el.className, className);\n\n\t\tel.className = newClass + (newClass && className ? ' ' : '') + className;\n\t}\n\n\t/**\n\t * Removes one or more css classes from a dom element.\n\t * @param el {HTMLElement}\n\t * @param className {String} a single css class or several, space-delimited\n\t *   css classes.\n\t */\n\tfunction removeClass (el, className) {\n\t\tel.className = _stripClass(el.className, className);\n\t}\n\n\t/**\n\t * Adds or removes one or more css classes from a dom element.\n\t * @param el {HTMLElement}\n\t * @param className {String} a single css class or several, space-delimited\n\t *   css classes.\n\t */\n\tfunction toggleClass (el, className) {\n\t\tvar unalteredClass;\n\n\t\t// save copy of what _stripClass would return if className\n\t\t// was not found\n\t\tunalteredClass = el.className.replace(trimLeadingRx, '');\n\n\t\t// remove className\n\t\tel.className = _stripClass(el.className, className);\n\n\t\t// add className if it wasn't removed\n\t\tif (unalteredClass == el.className) {\n\t\t\tel.className = unalteredClass + (unalteredClass && className ? ' ' : '') + className;\n\t\t}\n\t}\n\n\t/**\n\t * Super fast, one-pass, non-looping routine to remove one or more\n\t * space-delimited tokens from another space-delimited set of tokens.\n\t * @private\n\t * @param tokens\n\t * @param removes\n\t */\n\tfunction _stripClass (tokens, removes) {\n\t\tvar rx;\n\n\t\tif (!removes) {\n\t\t\treturn tokens;\n\t\t}\n\n\t\t// convert space-delimited tokens with bar-delimited (regexp `or`)\n\t\tremoves = removes.replace(splitClassNamesRx, function (m, inner, edge) {\n\t\t\t// only replace inner spaces with |\n\t\t\treturn edge ? '' : '|';\n\t\t});\n\n\t\t// create one-pass regexp\n\t\trx = new RegExp(classRx.replace('classNames', removes), 'g');\n\n\t\t// remove all tokens in one pass (wish we could trim leading\n\t\t// spaces in the same pass! at least the trim is not a full\n\t\t// scan of the string)\n\t\treturn tokens.replace(rx, '').replace(trimLeadingRx, '');\n\t}\n\n\tif (document && document.appendChild.apply) {\n\t\t// normal browsers\n\t\tnodeProxyInvoke = function jsInvoke (node, method, args) {\n\t\t\tif(typeof method == 'string') {\n\t\t\t\tmethod = node[method];\n\t\t\t}\n\t\t\treturn method.apply(node, args);\n\t\t};\n\t}\n\telse {\n\t\t// IE 6-8 (\"native\" methods don't have .apply()) so we have\n\t\t// to use eval())\n\t\tnodeProxyInvoke = function evalInvoke (node, method, args) {\n\t\t\tvar argsList;\n\n\t\t\tif(typeof method == 'function') {\n\t\t\t\treturn method.apply(node, args);\n\t\t\t}\n\n\t\t\t// iirc, no node methods have more than 4 parameters\n\t\t\t// (addEventListener), so 5 should be safe. Note: IE needs\n\t\t\t// the exact number of arguments or it will throw!\n\t\t\targsList = ['a', 'b', 'c', 'd', 'e'].slice(0, args.length).join(',');\n\n\t\t\t// function to execute eval (no need for global eval here\n\t\t\t// since the code snippet doesn't reference out-of-scope vars).\n\t\t\tfunction invoke (a, b, c, d, e) {\n\t\t\t\t/*jshint evil:true*/\n\t\t\t\treturn eval('node.' + method + '(' + argsList + ');');\n\t\t\t}\n\n\t\t\t// execute and return result\n\t\t\treturn invoke.apply(this, args);\n\t\t};\n\t}\n\n\tfunction byId(id) {\n\t\treturn document.getElementById(id);\n\t}\n\n\tfunction queryAll(selector, root) {\n\t\treturn (root||document).querySelectorAll(selector);\n\t}\n\n\tfunction query(selector, root) {\n\t\treturn (root||document).querySelector(selector);\n\t}\n\n\t/**\n\t * Places a node into the DOM at the location specified around\n\t * a reference node.\n\t * Note: replace is problematic if the dev expects to use the node\n\t * as a wire component.  The component reference will still point\n\t * at the node that was replaced.\n\t * @param node {HTMLElement}\n\t * @param refNode {HTMLElement}\n\t * @param location {String} or {Number} \"before\", \"after\", \"first\", \"last\",\n\t *   or the position within the children of refNode\n\t */\n\tfunction placeAt(node, refNode, location) {\n\t\tvar parent, i;\n\n\t\tif ('length' in refNode) {\n\t\t\tfor (i = 0; i < refNode.length; i++) {\n\t\t\t\tplaceAt(i === 0 ? node : node.cloneNode(true), refNode[i], location);\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\tparent = refNode.parentNode;\n\n\t\t// `if else` is more compressible than switch\n\t\tif (!isNaN(location)) {\n\t\t\tif (location < 0) {\n\t\t\t\tlocation = 0;\n\t\t\t}\n\t\t\t_insertBefore(refNode, node, refNode.childNodes[location]);\n\t\t}\n\t\telse if(location == 'at') {\n\t\t\trefNode.innerHTML = '';\n\t\t\t_appendChild(refNode, node);\n\t\t}\n\t\telse if(location == 'last') {\n\t\t\t_appendChild(refNode, node);\n\t\t}\n\t\telse if(location == 'first') {\n\t\t\t_insertBefore(refNode, node, refNode.firstChild);\n\t\t}\n\t\telse if(location == 'before') {\n\t\t\t// TODO: throw if parent missing?\n\t\t\t_insertBefore(parent, node, refNode);\n\t\t}\n\t\telse if(location == 'after') {\n\t\t\t// TODO: throw if parent missing?\n\t\t\tif (refNode == parent.lastChild) {\n\t\t\t\t_appendChild(parent, node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_insertBefore(parent, node, refNode.nextSibling);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new Error('Unknown dom insertion command: ' + location);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t// these are for better compressibility since compressors won't\n\t// compress native DOM methods.\n\tfunction _insertBefore(parent, node, refNode) {\n\t\tparent.insertBefore(node, refNode);\n\t}\n\n\tfunction _appendChild(parent, node) {\n\t\tparent.appendChild(node);\n\t}\n\n\tfunction isNode(it) {\n\t\treturn typeof Node === \"object\"\n\t\t\t? it instanceof Node\n\t\t\t: it && typeof it === \"object\" && typeof it.nodeType === \"number\" && typeof it.nodeName===\"string\";\n\t}\n\n\tfunction NodeProxy() {}\n\n\tNodeProxy.prototype = {\n\t\tget: function (name) {\n\t\t\tvar node = this.target;\n\n\t\t\tif (name in node) {\n\t\t\t\treturn node[name];\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn node.getAttribute(name);\n\t\t\t}\n\t\t},\n\n\t\tset: function (name, value) {\n\t\t\tvar node = this.target;\n\n\t\t\tif (name in node) {\n\t\t\t\treturn node[name] = value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn node.setAttribute(name, value);\n\t\t\t}\n\t\t},\n\n\t\tinvoke: function (method, args) {\n\t\t\treturn nodeProxyInvoke(this.target, method, args);\n\t\t},\n\n\t\tdestroy: function () {\n\t\t\tvar node = this.target;\n\n\t\t\t// if we added a destroy method on the node, call it.\n\t\t\t// TODO: find a better way to release events instead of using this mechanism\n\t\t\tif (node.destroy) {\n\t\t\t\tnode.destroy();\n\t\t\t}\n\t\t\t// removal from document will destroy node as soon as all\n\t\t\t// references to it go out of scope.\n\t\t\tvar parent = node.parentNode;\n\t\t\tif (parent) {\n\t\t\t\tparent.removeChild(node);\n\t\t\t}\n\t\t},\n\n\t\tclone: function (options) {\n\t\t\tif (!options) {\n\t\t\t\toptions = {};\n\t\t\t}\n\t\t\t// default is to clone deep (when would anybody not want deep?)\n\t\t\treturn this.target.cloneNode(!('deep' in options) || options.deep);\n\t\t}\n\t};\n\n\tproxyNode.priority = priority.basePriority;\n\tfunction proxyNode (proxy) {\n\n\t\tif (!isNode(proxy.target)) {\n\t\t\treturn proxy;\n\t\t}\n\n\t\treturn WireProxy.extend(proxy, NodeProxy.prototype);\n\t}\n\n\treturn {\n\n\t\tbyId: byId,\n\t\tquerySelector: query,\n\t\tquerySelectorAll: queryAll,\n\t\tplaceAt: placeAt,\n\t\taddClass: addClass,\n\t\tremoveClass: removeClass,\n\t\ttoggleClass: toggleClass,\n\t\tproxyNode: proxyNode\n\n\t};\n\n});\n}(\n\ttypeof define == 'function' && define.amd\n\t\t? define\n\t\t: function (factory) { module.exports = factory(require); }\n));\n","modules":[{"pos":336,"count":26,"factory":true,"argList":["require"],"requires":[{"id":"../WireProxy","pos":465,"count":23},{"id":"../plugin/priority","pos":502,"count":29}],"id":"wire/lib/dom/base"}],"compileTime":"2014-03-24T21:53:07.503Z"}