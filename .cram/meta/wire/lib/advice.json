{"absId":"wire/lib/advice","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/wire/lib/advice.js","source":"/** @license MIT License (c) copyright 2010-2013 original author or authors */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author: Brian Cavalier\n * @author: John Hann\n */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar when;\n\n\twhen = require('when');\n\n\t// Very simple advice functions for internal wire use only.\n\t// This is NOT a replacement for meld.  These advices stack\n\t// differently and will not be as efficient.\n\treturn {\n\t\tbefore: before,\n\t\tafter: after,\n\t\tbeforeAsync: beforeAsync,\n\t\tafterAsync: afterAsync\n\t};\n\n\t/**\n\t * Execute advice before f, passing same arguments to both, and\n\t * discarding advice's return value.\n\t * @param {function} f function to advise\n\t * @param {function} advice function to execute before f\n\t * @returns {function} advised function\n\t */\n\tfunction before(f, advice) {\n\t\treturn function() {\n\t\t\tadvice.apply(this, arguments);\n\t\t\treturn f.apply(this, arguments);\n\t\t}\n\t}\n\n\t/**\n\t * Execute advice after f, passing f's return value to advice\n\t * @param {function} f function to advise\n\t * @param {function} advice function to execute after f\n\t * @returns {function} advised function\n\t */\n\tfunction after(f, advice) {\n\t\treturn function() {\n\t\t\treturn advice.call(this, f.apply(this, arguments));\n\t\t}\n\t}\n\n\t/**\n\t * Execute f after a promise returned by advice fulfills. The same args\n\t * will be passed to both advice and f.\n\t * @param {function} f function to advise\n\t * @param {function} advice function to execute before f\n\t * @returns {function} advised function which always returns a promise\n\t */\n\tfunction beforeAsync(f, advice) {\n\t\treturn function() {\n\t\t\tvar self, args;\n\n\t\t\tself = this;\n\t\t\targs = arguments;\n\n\t\t\treturn when(args, function() {\n\t\t\t\treturn advice.apply(self, args);\n\t\t\t}).then(function() {\n\t\t\t\treturn f.apply(self, args);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Execute advice after a promise returned by f fulfills. The same args\n\t * will be passed to both advice and f.\n\t * @param {function} f function to advise\n\t * @param {function} advice function to execute after f\n\t * @returns {function} advised function which always returns a promise\n\t */\n\tfunction afterAsync(f, advice) {\n\t\treturn function() {\n\t\t\tvar self = this;\n\n\t\t\treturn when(arguments, function(args) {\n\t\t\t\treturn f.apply(self, args);\n\t\t\t}).then(function(result) {\n\t\t\t\treturn advice.call(self, result);\n\t\t\t});\n\t\t}\n\t}\n\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","modules":[{"pos":267,"count":25,"factory":true,"argList":["require"],"requires":[{"id":"when","pos":315,"count":15}],"id":"wire/lib/advice"}],"compileTime":"2014-03-24T21:53:07.508Z"}