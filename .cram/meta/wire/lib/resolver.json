{"absId":"wire/lib/resolver","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/wire/lib/resolver.js","source":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define){ 'use strict';\ndefine(function(require) {\n\n\tvar when, timeout, object;\n\n\twhen = require('when');\n\ttimeout = require('when/timeout');\n\tobject = require('./object');\n\n\t/**\n\t * Create a reference resolve that uses the supplied plugins and pluginApi\n\t * @param {object} config\n\t * @param {object} config.plugins plugin registry\n\t * @param {object} config.pluginApi plugin Api to provide to resolver plugins\n\t *  when resolving references\n\t * @constructor\n\t */\n\tfunction Resolver(resolvers, pluginApi) {\n\t\tthis._resolvers = resolvers;\n\t\tthis._pluginApi = pluginApi;\n\t}\n\n\tResolver.prototype = {\n\n\t\t/**\n\t\t * Determine if it is a reference spec that can be resolved by this resolver\n\t\t * @param {*} it\n\t\t * @return {boolean} true iff it is a reference\n\t\t */\n\t\tisRef: function(it) {\n\t\t\treturn it && object.hasOwn(it, '$ref');\n\t\t},\n\n\t\t/**\n\t\t * Parse it, which must be a reference spec, into a reference object\n\t\t * @param {object|string} it\n\t\t * @param {string?} it.$ref\n\t\t * @return {object} reference object\n\t\t */\n\t\tparse: function(it) {\n\t\t\treturn this.isRef(it)\n\t\t\t\t? this.create(it.$ref, it)\n\t\t\t\t: this.create(it, {});\n\t\t},\n\n\t\t/**\n\t\t * Creates a reference object\n\t\t * @param {string} name reference name\n\t\t * @param {object} options\n\t\t * @return {{resolver: String, name: String, options: object, resolve: Function}}\n\t\t */\n\t\tcreate: function(name, options) {\n\t\t\tvar self, split, resolver;\n\n\t\t\tself = this;\n\n\t\t\tsplit = name.indexOf('!');\n\t\t\tresolver = name.substring(0, split);\n\t\t\tname = name.substring(split + 1);\n\n\t\t\treturn {\n\t\t\t\tresolver: resolver,\n\t\t\t\tname: name,\n\t\t\t\toptions: options,\n\t\t\t\tresolve: function(fallback, onBehalfOf) {\n\t\t\t\t\treturn this.resolver\n\t\t\t\t\t\t? self._resolve(resolver, name, options, onBehalfOf)\n\t\t\t\t\t\t: fallback(name, options);\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Do the work of resolving a reference using registered plugins\n\t\t * @param {string} resolverName plugin resolver name (e.g. \"dom\"), the part before the \"!\"\n\t\t * @param {string} name reference name, the part after the \"!\"\n\t\t * @param {object} options additional options to pass thru to a resolver plugin\n\t\t * @param {string|*} onBehalfOf some indication of another component on whose behalf this\n\t\t *  reference is being resolved.  Used to build a reference graph and detect cycles\n\t\t * @return {object} promise for the resolved reference\n\t\t * @private\n\t\t */\n\t\t_resolve: function(resolverName, name, options, onBehalfOf) {\n\t\t\tvar deferred, resolver, api;\n\n\t\t\tdeferred = when.defer();\n\n\t\t\tif (resolverName) {\n\t\t\t\tresolver = this._resolvers[resolverName];\n\n\t\t\t\tif (resolver) {\n\t\t\t\t\tapi = this._pluginApi.contextualize(onBehalfOf);\n\t\t\t\t\tresolver(deferred.resolver, name, options||{}, api);\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.reject(new Error('No resolver plugin found: ' + resolverName));\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tdeferred.reject(new Error('Cannot resolve ref: ' + name));\n\t\t\t}\n\n\t\t\treturn deferred.promise;\n\t\t}\n\t};\n\n\treturn Resolver;\n\n});\n})(typeof define == 'function'\n\t// AMD\n\t? define\n\t// CommonJS\n\t: function(factory) { module.exports = factory(require); }\n);","modules":[{"pos":197,"count":25,"factory":true,"argList":["require"],"requires":[{"id":"when","pos":262,"count":15},{"id":"when/timeout","pos":290,"count":23},{"id":"./object","pos":325,"count":19}],"id":"wire/lib/resolver"}],"compileTime":"2014-03-24T21:53:07.510Z"}