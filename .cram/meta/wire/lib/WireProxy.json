{"absId":"wire/lib/WireProxy","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/wire/lib/WireProxy.js","source":"/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n */\n\n(function(define){ 'use strict';\ndefine(function(require) {\n\n\tvar object, array;\n\n\tobject = require('./object');\n\tarray = require('./array');\n\n\t/**\n\t * A base proxy for all components that wire creates.  It allows wire's\n\t * internals and plugins to work with components using a standard interface.\n\t * WireProxy instances may be extended to specialize the behavior of the\n\t * interface for a particular type of component.  For example, there is a\n\t * specialized version for DOM Nodes.\n\t * @param {*} target value to be proxied\n\t * @constructor\n\t */\n\tfunction WireProxy(target) {\n\t\t// read-only target\n\t\tObject.defineProperty(this, 'target', { value: target });\n\t}\n\n\tWireProxy.prototype = {\n\t\t/**\n\t\t * Get the value of the named property. Sub-types should\n\t\t * override to get properties from their targets in whatever\n\t\t * specialized way is necessary.\n\t\t * @param {string} property\n\t\t * @returns {*} the value or undefined\n\t\t */\n\t\tget: function (property) {\n\t\t\treturn this.target[property];\n\t\t},\n\n\t\t/**\n\t\t * Set the value of the named property. Sub-types should\n\t\t * override to set properties on their targets in whatever\n\t\t * specialized way is necessary.\n\t\t * @param {string} property\n\t\t * @param {*} value\n\t\t * @returns {*}\n\t\t */\n\t\tset: function (property, value) {\n\t\t\tthis.target[property] = value;\n\t\t\treturn value;\n\t\t},\n\n\t\t/**\n\t\t * Invoke the method, with the supplied args, on the proxy's\n\t\t * target. Sub-types should override to invoke methods their\n\t\t * targets in whatever specialized way is necessary.\n\t\t * @param {string|function} method name of method to invoke or\n\t\t *  a function to call using proxy's target as the thisArg\n\t\t * @param {array} args arguments to pass to method\n\t\t * @returns {*} the method's return value\n\t\t */\n\t\tinvoke: function (method, args) {\n\t\t\tvar target = this.target;\n\n\t\t\tif (typeof method === 'string') {\n\t\t\t\tmethod = target[method];\n\t\t\t}\n\n\t\t\treturn method.apply(target, array.fromArguments(args));\n\t\t},\n\n\t\t/**\n\t\t * Add an aspect to the proxy's target. Sub-types should\n\t\t * override to add aspects in whatever specialized way is\n\t\t * necessary.\n\t\t * @param {String|Array|RegExp|Function} pointcut\n\t\t *  expression matching methods to be advised\n\t\t * @param {Object} aspect aspect to add\n\t\t * @returns {{remove:function}} object with remove() that\n\t\t *  will remove the aspect.\n\t\t */\n\t\tadvise: function(pointcut, aspect) {\n\t\t\tthrow new TypeError('Advice not supported on component type: ' + this.target);\n\t\t},\n\n\t\t/**\n\t\t * Destroy the proxy's target.  Sub-types should override\n\t\t * to destroy their targets in whatever specialized way is\n\t\t * necessary.\n\t\t */\n\t\tdestroy: function() {},\n\n\t\t/**\n\t\t * Attempt to clone this proxy's target. Sub-types should\n\t\t * override to clone their targets in whatever specialized\n\t\t * way is necessary.\n\t\t * @param {object|array|function} thing thing to clone\n\t\t * @param {object} options\n\t\t * @param {boolean} options.deep if true and thing is an Array, try to deep clone its contents\n\t\t * @param {boolean} options.inherited if true and thing is an object, clone inherited and own properties.\n\t\t * @returns {*}\n\t\t */\n\t\tclone: function (options) {\n\t\t\t// don't try to clone a primitive\n\t\t\tvar target = this.target;\n\n\t\t\tif (typeof target == 'function') {\n\t\t\t\t// cloneThing doesn't clone functions, so clone here:\n\t\t\t\treturn target.bind();\n\t\t\t} else if (typeof target != 'object') {\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\treturn cloneThing(target, options || {});\n\t\t}\n\t};\n\n\tWireProxy.isProxy = isProxy;\n\tWireProxy.getTarget = getTarget;\n\tWireProxy.extend = extendProxy;\n\n\treturn WireProxy;\n\n\t/**\n\t * Returns a new WireProxy, whose prototype is proxy, with extensions\n\t * as own properties.  This is the \"official\" way to extend the functionality\n\t * of an existing WireProxy.\n\t * @param {WireProxy} proxy proxy to extend\n\t * @param extensions\n\t * @returns {*}\n\t */\n\tfunction extendProxy(proxy, extensions) {\n\t\tif(!isProxy(proxy)) {\n\t\t\tthrow new Error('Cannot extend non-WireProxy');\n\t\t}\n\n\t\treturn object.extend(proxy, extensions);\n\t}\n\n\t/**\n\t * Returns true if it is a WireProxy\n\t * @param {*} it\n\t * @returns {boolean}\n\t */\n\tfunction isProxy(it) {\n\t\treturn it instanceof WireProxy;\n\t}\n\n\t/**\n\t * If it is a WireProxy (see isProxy), returns it's target.  Otherwise,\n\t * returns it;\n\t * @param {*} it\n\t * @returns {*}\n\t */\n\tfunction getTarget(it) {\n\t\treturn isProxy(it) ? it.target : it;\n\t}\n\n\t/**\n\t * Try to clone thing, which can be an object, Array, or Function\n\t * @param {object|array|function} thing thing to clone\n\t * @param {object} options\n\t * @param {boolean} options.deep if true and thing is an Array, try to deep clone its contents\n\t * @param {boolean} options.inherited if true and thing is an object, clone inherited and own properties.\n\t * @returns {array|object|function} cloned thing\n\t */\n\tfunction cloneThing (thing, options) {\n\t\tvar deep, inherited, clone, prop;\n\t\tdeep = options.deep;\n\t\tinherited = options.inherited;\n\n\t\t// Note: this filters out primitive properties and methods\n\t\tif (typeof thing != 'object') {\n\t\t\treturn thing;\n\t\t}\n\t\telse if (thing instanceof Date) {\n\t\t\treturn new Date(thing.getTime());\n\t\t}\n\t\telse if (thing instanceof RegExp) {\n\t\t\treturn new RegExp(thing);\n\t\t}\n\t\telse if (Array.isArray(thing)) {\n\t\t\treturn deep\n\t\t\t\t? thing.map(function (i) { return cloneThing(i, options); })\n\t\t\t\t: thing.slice();\n\t\t}\n\t\telse {\n\t\t\tclone = thing.constructor ? new thing.constructor() : {};\n\t\t\tfor (prop in thing) {\n\t\t\t\tif (inherited || object.hasOwn(thing, prop)) {\n\t\t\t\t\tclone[prop] = deep\n\t\t\t\t\t\t? cloneThing(thing[prop], options)\n\t\t\t\t\t\t: thing[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clone;\n\t\t}\n\t}\n\n});\n})(typeof define == 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }\n);","modules":[{"pos":197,"count":25,"factory":true,"argList":["require"],"requires":[{"id":"./object","pos":256,"count":19},{"id":"./array","pos":286,"count":18}],"id":"wire/lib/WireProxy"}],"compileTime":"2014-03-24T21:53:07.511Z"}